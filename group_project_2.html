<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title>Antithetic Variates, Ray Casting Algorithm</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<div class="container-fluid main-container">

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->





<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Pages</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Basic Task</a>
</li>
<li>
  <a href="extension_write_up.html">Mathematical Methods</a>
</li>
<li>
  <a href="Generating_convex_polygons.html">Generating Convex Polygons</a>
</li>
<li>
  <a href="group_project_2.html">Antithetic Variates</a>
</li>
<li>
  <a href="Polygons.html">Pick's Theorem &amp; Monte Carlo</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Antithetic Variates, Ray Casting Algorithm</h1>

</div>


<p><span class="math inline">\(\newcommand{\Var}{\mathrm{Var}}\)</span> <span class="math inline">\(\newcommand{\Cov}{\mathrm{Cov}}\)</span></p>
<div id="defining-the-function" class="section level2">
<h2>Defining the Function</h2>
<pre class="r"><code>x &lt;- c(1,3,4.5,3)
y &lt;- c(1,2,1,0.5)
p &lt;- c(3,1)

norm_vec &lt;- function(x) sqrt(sum(x^2))
dot &lt;- function(x,y) sum(x*y)
angle &lt;- function(x,y){
  theta &lt;- acos(dot(x,y)/(norm_vec(x)*norm_vec(y)))
  return(theta)
}

in_or_out &lt;- function(x,y,p){
  total_angle &lt;- 0
  for (i in 1:length(x)){
    if (i == length(x)){
      vector1 &lt;- c(x[i] - p[1], y[i] - p[2])
      vector2 &lt;- c(x[1] - p[1], y[1] - p[2])
      total_angle &lt;- total_angle + angle(vector1, vector2)
    } else{
      vector1 &lt;- c(x[i] - p[1], y[i] - p[2])
      vector2 &lt;- c(x[i+1] - p[1], y[i+1] - p[2])
      total_angle &lt;- total_angle + angle(vector1, vector2)
    }
  }
  if (round(total_angle, 5) == round(2*pi,5)){
    return(TRUE)
  } else{
    return(FALSE)
  }
}

in_or_out(x,y,p)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>counter * 1/10000</code></pre>
<pre><code>## [1] 0.5045</code></pre>
</div>
<div id="antithetic-variates" class="section level2">
<h2>Antithetic Variates</h2>
<p>An unfortunate disadvantage of this method is that it’s reliant on the law of large numbers [1] and takes many samples to achieve an accurate result. However, by the central limit theorem [2], for a fixed interval <span class="math inline">\(\alpha\)</span> an unknown true mean lies in the interval <span class="math inline">\(\bar{X} \pm z_{(1 - \alpha)} \frac{\sigma}{\sqrt{n}}\)</span>. Letting <span class="math inline">\(\alpha\)</span> be a confidence interval of <span class="math inline">\(99\%\)</span> gives that the mean will lie between <span class="math inline">\(\bar{X} \pm z_{0.01} \frac{\sigma}{\sqrt{n}} = \bar{X} \pm 2.5758 \frac{\sigma}{\sqrt{n}}.\)</span> By this equation you’ll notice that while increasing the number of observations will decrease this range, decreasing the variance will also achieve the same thing. This can be done with Antithetic Variates.</p>
<p>Let <span class="math inline">\(\bar Y_1\)</span> and <span class="math inline">\(\bar Y_2\)</span> be estimators with an equal mean and variance for an unknown sample with mean <span class="math inline">\(E(X).\)</span> An unbiased estimate of <span class="math inline">\(E(X)\)</span> is given by <span class="math inline">\(\hat{X} = \frac{\hat{Y_1} + \hat{Y_2}}{2}.\)</span> The variance is given by <span class="math inline">\(\Var{X} = \frac{\Var{Y_1} + \Var{Y_2} + 2\Cov(Y_1,Y_2)}{4}\)</span> however as <span class="math inline">\(Y_1\)</span> and <span class="math inline">\(Y_2\)</span> have the same variance, the variance of <span class="math inline">\(X\)</span> can be written as <span class="math inline">\(\Var(X) = \frac{\Var(Y_1) + \Cov(Y_1,Y_2)}{2}\)</span>. You’ll observe that the variance decreases when the covariance of <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> is negative.</p>
<p>As an extreme example, consider the uniform distribution <span class="math inline">\(U[0,1]\)</span> with mean <span class="math inline">\(0.5\)</span> and variance <span class="math inline">\(\frac{1}{12}\)</span>. Generating <span class="math inline">\(1000\)</span> samples of this distribution can be done thusly</p>
<pre class="r"><code>x &lt;- runif(1000, 0, 1)</code></pre>
<p>Finding a distribution that negatively correlates with the uniform distribution is fairly trivial as you can generate a new variate <span class="math inline">\(Y\)</span> such that <span class="math inline">\(Y = 1 - X.\)</span></p>
<pre class="r"><code>y &lt;- 1 - x
var(x)</code></pre>
<pre><code>## [1] 0.08434493</code></pre>
<pre class="r"><code>cov(x,y)</code></pre>
<pre><code>## [1] -0.08434493</code></pre>
<p>As the variance of <span class="math inline">\(x\)</span> is exactly the negative of <span class="math inline">\(\Cov(x,y)\)</span>, <span class="math inline">\(\frac{x_i + y_i}{2}\)</span> will return the mean of <span class="math inline">\(X\)</span> exactly as the sum <span class="math inline">\(\frac{x_i + y_i}{2}\)</span> will equal <span class="math inline">\(1\)</span>. This is due to the fact that by the earlier formula the variance of <span class="math inline">\(\frac{x_i + y_i}{2}\)</span> is equal to <span class="math inline">\(0\)</span>, whereas summing <span class="math inline">\(2\)</span> independent variables will have variance <span class="math inline">\(\frac{1}{6}\)</span> by the formula <span class="math inline">\(\Var{(X+Y)} = \Var{X} + \Var{Y}\)</span>.</p>
<pre class="r"><code>mean(c(x,y))</code></pre>
<pre><code>## [1] 0.5</code></pre>
</div>
<div id="the-ray-casting-algorithm" class="section level2">
<h2>The ray casting algorithm</h2>
<p>Whilst the previous algorithm works for many of the shapes we would like to calculate the area of, it has inherit flaws. Firstly, it will only work for convex polygons. You’ll notice that it’s easy to construct a concave polygon for which this method obtains a number greater or less than <span class="math inline">\(2 \pi.\)</span> Also in calculating the angle between the two vectors, the algorithm employs the computationally expensive <span class="math inline">\(\arccos\)</span> function. Whilst this is acceptable for single uses, the Monte Carlo method requires a large number of samples to guarantee an accurate estimate. This makes the function undesirable in many cases.</p>
<p>Fortunately there exists a better algorithm that works for all polygons and contains no complex calculations. The ray casting algorithm works by extending a line from the point to infinity and counting the number of intersections with the edges of the polygon. If the number of intersections is even, the point lies outside the polygon and if odd, the point lies inside the shape. This works by considering that everytime the line intersects an edge the line changes from being inside the polygon to outside and vice versa. Though because the shape is closed and finite, the line must always end up outside of the shape because it’s length is infinite. Therefore we can just count backwards from the line being outside the shape initially to being inside after one intersection to being outside again after another and so on.</p>
<pre class="python"><code>x = [3,9,13,12,6]
# List of all x ordinates such that each co-ordinate is next to the next vertex
y = [3,2,4,7,6]
# List of all y ordinates
p = [7,4]
# x and y co-ordinates of the point that we&#39;re determining is inside or outside the polygon 

def equation(p1,p2,y):
    if (p1[1] - p2[1] != 0):
        t = (y - p1[1])/(p1[1] - p2[1])
        return(p1[0] + (p1[0] - p2[0]*t))
        
#The equation function uses the vector equation of a line to find the equation of the line between two vertices. It then finds the x co-ordinate when y equals a certain number on that line.

intersections = []

for i in range(len(x)-1):
    if (i == len(x)-1):
        p1 = [x[i],x[1]]
        p2 = [y[i],y[1]]
        if ((p1[1] &lt; p[1] and p2[1] &gt; p[1]) or (p1[1] &gt; p[1] and p2[1] &lt; p[1])):
            if (equation(p1, p2, p[1]) &gt; p[0]):
                intersections.append(equation(p1, p2, p[1]))
    else:
        p1 = [x[i],x[i+1]]
        p2 = [y[i],y[i+1]]
        if ((p1[1] &lt; p[1] and p2[1] &gt; p[1]) or (p1[1] &gt; p[1] and p2[1] &lt; p[1])):
            if (equation(p1, p2, p[1]) &gt; p[0]):
                intersections.append(equation(p1, p2, p[1]))
                
#This for loop finds when the line to infinity intersects the edge of the polygon. For each edge in the polygon it checks for the following conditions: Is the y co-ordinate of one of the vertices greater than the y co-ordinate of the point and is the other one below? This is checked as for a horizontal line to pass througb an edge it must pass between two points one of which is above the line and the other below. If this is true it then finds the point at which the edge intersects with the y co-ordinate of the line. If this is in the right hand side of where the point is then the line must intersect wuth the edge. So the function adds the x co-ordinate to the list ofintersections.

if (len(intersections) % 2 == 1):
    print(&quot;inside&quot;)
else:
    print(&quot;outside&quot;)
    
#If there are an odd number of these intersections, the point must lie inside the polygon. Else, it lies outside.</code></pre>
<pre><code>## inside</code></pre>
</div>
<div id="using-a-regular-grid" class="section level2">
<h2>Using a regular grid</h2>
<p>Using the same point in polygon program as earlier and some basic recursion, we can construct a regular grid to estimate the areas of these polygons.</p>
<pre class="python"><code>def raycasting(x,y,p):
    intersections = []

    for i in range(len(x)-1):
        if (i == len(x)-1):
            p1 = [x[i],x[1]]
            p2 = [y[i],y[1]]
            if ((p1[1] &lt; p[1] and p2[1] &gt; p[1]) or (p1[1] &gt; p[1] and p2[1] &lt; p[1])):
                if (equation(p1, p2, p[1]) &gt; p[0]):
                    intersections.append(equation(p1, p2, p[1]))
        else:
            p1 = [x[i],x[i+1]]
            p2 = [y[i],y[i+1]]
            if ((p1[1] &lt; p[1] and p2[1] &gt; p[1]) or (p1[1] &gt; p[1] and p2[1] &lt; p[1])):
                if (equation(p1, p2, p[1]) &gt; p[0]):
                    intersections.append(equation(p1, p2, p[1]))

    if (len(intersections) % 2 == 1):
        return(&quot;inside&quot;)
    else:
        return(&quot;outside&quot;)
        
        
print(raycasting(x,y,p))</code></pre>
<pre><code>## inside</code></pre>
<pre class="python"><code>counter = 0
for i in range(1000):
    for j in range(1000):
        p = [13*i/1000,7*j/1000]
        if (raycasting(x,y,p) == &quot;inside&quot;):
            counter += 1

print(counter/1000000 * 13 * 7)</code></pre>
<pre><code>## 33.629687000000004</code></pre>
<p>While this method works in theory, it scales poorly. For example, to generate just <span class="math inline">\(1000\)</span> intervals in <span class="math inline">\(2\)</span> dimensions, you need to generate <span class="math inline">\(1,000,000\)</span> co-ordinates. This becomes even more problematic in higher dimensions. For instance, to create a grid with <span class="math inline">\(n\)</span> points in <span class="math inline">\(30\)</span> dimensions will take <span class="math inline">\(n^{30}\)</span> evaluations. Therefore to generate a grid of <span class="math inline">\(1000\)</span> points as was done previously would take <span class="math inline">\(1000^{30}\)</span> co-ordinates equal to <span class="math inline">\(10^{90}\)</span> evaluations. To put this number in perspective, it’s estimated that there are between <span class="math inline">\(10^{78}\)</span> and <span class="math inline">\(10^{82}\)</span> atoms in the observable universe [3].</p>
<p>This is commonly known as the curse of dimensionality where problems arise in higher dimensions that don’t exist in lower dimensions. Fortunately, the Monte Carlo method converges at a rate depending on the variance of the variables and the number of observations. This means it is dimensionally independent and scales well in higher dimensions.</p>
</div>
<div id="references" class="section level2">
<h2>References</h2>
<p>[1] <a href="https://www.britannica.com/science/law-of-large-numbers" class="uri">https://www.britannica.com/science/law-of-large-numbers</a></p>
<p>[2] <a href="https://www.investopedia.com/terms/c/central_limit_theorem.asp" class="uri">https://www.investopedia.com/terms/c/central_limit_theorem.asp</a></p>
<p>[3] <a href="https://www.universetoday.com/36302/atoms-in-the-universe/amp/" class="uri">https://www.universetoday.com/36302/atoms-in-the-universe/amp/</a></p>
<p><a href="https://rosettacode.org/wiki/Ray-casting_algorithm" class="uri">https://rosettacode.org/wiki/Ray-casting_algorithm</a></p>
<p><a href="http://www.columbia.edu/~ks20/4703-Sigman/4703-07-Notes-ATV.pdf" class="uri">http://www.columbia.edu/~ks20/4703-Sigman/4703-07-Notes-ATV.pdf</a></p>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
